//
// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

@import "@material/animation/variables";
@import "@material/theme/functions";
@import "@material/theme/mixins";
@import "./keyframes";
@import "./variables";

// Ensure that styles needed by any component using MDC Ripple are emitted, but only once.
// (Every component using MDC Ripple imports these mixins, but doesn't necessarily import mdc-ripple.scss.)

// This variable is not intended to be overridden externally; it uses !default to avoid being reset
// every time this file is imported.
$mdc-ripple-common-styles-emitted_: false !default;

@if not $mdc-ripple-common-styles-emitted_ {
  $mdc-ripple-common-styles-emitted_: true;

  @include mdc-ripple-keyframes_;

  // Styles used to detect buggy behavior of CSS custom properties in Edge.
  // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
  // This is included in _mixins.scss rather than mdc-ripple.scss so that it will be
  // present for other components which rely on ripple as well as mdc-ripple itself.
  .mdc-ripple-surface--test-edge-var-bug {
    --mdc-ripple-surface-test-edge-var: 1px solid #000;

    visibility: hidden;

    &::before {
      border: var(--mdc-ripple-surface-test-edge-var);
    }
  }
}

@mixin mdc-ripple-surface() {
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);

  &::before,
  &::after {
    position: absolute;
    border-radius: 50%;
    pointer-events: none;
    will-change: transform, opacity;
    content: "";
  }

  &::before {
    transition: opacity $mdc-states-wash-duration linear;
  }
}

@mixin mdc-ripple-color($color: black, $opacity-map: null) {
  @if not $opacity-map {
    $opacity-map: if(mdc-theme-luminance($color) > .5, $mdc-ripple-light-ink-opacities, $mdc-ripple-dark-ink-opacities);
  }

  // Opacity styles are here (rather than in mdc-ripple-surface) to ensure that opacity is re-initialized for
  // cases where this mixin is used to override another inherited use of itself,
  // without needing to re-include mdc-ripple-surface.
  &::before,
  &::after {
    @include mdc-theme-prop(background-color, $color);

    opacity: 0;
  }

  // Background wash styles, for both CSS-only and upgraded stateful surfaces

  &:hover::before {
    opacity: map-get($opacity-map, 'hover');
  }

  // Focus overrides hover by reusing the ::before pseudo-element.
  // This is done for CSS-only surfaces as well as upgraded ripples after focus ripple has completed.
  // TODO(kfranqueiro): Is it possible to avoid nuking hover background when focus ripple occurs?
  &:not(.mdc-ripple-upgraded--focusing):focus::before {
    opacity: map-get($opacity-map, 'focus');
  }

  &:not(.mdc-ripple-upgraded):focus::before {
    // Note that this is only effective on focus, not blur
    transition-duration: 75ms;
  }

  // Styles for non-upgraded (CSS-only) stateful surfaces

  &:not(.mdc-ripple-upgraded) {
    // Apply press additively by using the ::after pseudo-element
    &:active::after {
      opacity: map-get($opacity-map, 'press');
    }
  }

  // Styles for ripple-upgraded surfaces

  &.mdc-ripple-upgraded {
    --mdc-ripple-fg-size: 0;
    --mdc-ripple-left: 0;
    --mdc-ripple-top: 0;
    --mdc-ripple-fg-opacity: map-get($opacity-map, 'press');
    --mdc-ripple-fg-scale: 1;
    --mdc-ripple-fg-translate-end: 0;
    --mdc-ripple-fg-translate-start: 0;
  }

  // Foreground ripple styles, for upgraded stateful surfaces

  // Focus ripple requires its own selector, since :focus also tends to be applied upon press
  &.mdc-ripple-upgraded--focusing {
    // Change opacity used for ripple when it is triggered on focus rather than press
    --mdc-ripple-fg-opacity: map-get($opacity-map, 'focus');

    &::before {
      opacity: 0;
    }
  }

  &.mdc-ripple-upgraded--foreground-activation::after {
    animation: 225ms mdc-ripple-fg-radius-in forwards, 75ms mdc-ripple-fg-opacity-in forwards;
  }

  &.mdc-ripple-upgraded--foreground-deactivation::after {
    animation: 150ms mdc-ripple-fg-opacity-out;
    // Retain transform from mdc-ripple-fg-radius-in activation
    transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));
  }

  // FIXME: This is seemingly never applying
  &.mdc-ripple-upgraded--focusing.mdc-ripple-upgraded--foreground-deactivation::after {
    animation-duration: 30ms;
  }
}

@mixin mdc-ripple-radius($radius: 100%) {
  &::before,
  &::after {
    top: calc(50% - #{$radius});
    left: calc(50% - #{$radius});
    width: $radius * 2;
    height: $radius * 2;
  }

  // Background ripple styles

  &.mdc-ripple-upgraded::before {
    top: calc(50% - #{$radius});
    left: calc(50% - #{$radius});
    width: $radius * 2;
    height: $radius * 2;
    transform: scale(var(--mdc-ripple-fg-scale, 0));
  }

  &.mdc-ripple-upgraded--unbounded::before {
    top: var(--mdc-ripple-top, calc(50% - #{$radius / 2}));
    left: var(--mdc-ripple-left, calc(50% - #{$radius / 2}));
    width: var(--mdc-ripple-fg-size, $radius);
    height: var(--mdc-ripple-fg-size, $radius);
    transform: scale(var(--mdc-ripple-fg-scale, 0));
  }

  // Foreground ripple styles
  &.mdc-ripple-upgraded::after {
    top: 0;
    left: 0;
    width: var(--mdc-ripple-fg-size, $radius);
    height: var(--mdc-ripple-fg-size, $radius);
    transform: scale(0);
    transform-origin: center center;
  }

  &.mdc-ripple-upgraded--unbounded::after {
    top: var(--mdc-ripple-top, 0);
    left: var(--mdc-ripple-left, 0);
  }
}
